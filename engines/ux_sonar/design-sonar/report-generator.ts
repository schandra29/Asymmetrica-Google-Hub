/**
 * Design Sonar Report Generator
 * Generates comprehensive Markdown reports with harmony metrics and code fixes
 */

import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

export class DesignReportGenerator {

  generateMarkdownReport(critique: any, telemetry: any, route: string): string {
    const timestamp = new Date().toISOString();

    let report = `# Design Sonar Report - ${route}

**Generated:** ${timestamp}
**Regime:** ${telemetry.asymmetrica.regime}
**Harmony Index:** ${telemetry.metrics.harmonyIndex.toFixed(1)}/100
**Overall Score:** ${critique.metrics.overallScore.toFixed(1)}/100

---

## Summary

${critique.summary}

---

## Harmony Metrics

| Metric | Value | Target | Status |
|--------|-------|--------|--------|
| **Harmony Index** | ${telemetry.metrics.harmonyIndex.toFixed(1)} | ≥85 | ${telemetry.metrics.harmonyIndex >= 85 ? '✅' : telemetry.metrics.harmonyIndex >= 70 ? '⚠️' : '❌'} |
| **Contrast Score** | ${telemetry.metrics.contrastScore.toFixed(1)} | ≥70 | ${telemetry.metrics.contrastScore >= 70 ? '✅' : '⚠️'} |
| **Hierarchy Score** | ${telemetry.metrics.hierarchyScore.toFixed(1)} | ≥80 | ${telemetry.metrics.hierarchyScore >= 80 ? '✅' : '⚠️'} |
| **Spacing Score** | ${telemetry.metrics.spacingScore.toFixed(1)} | ≥80 | ${telemetry.metrics.spacingScore >= 80 ? '✅' : '⚠️'} |
| **Breathability** | ${telemetry.metrics.breathabilityIndex.toFixed(2)} | ≥0.35 | ${telemetry.metrics.breathabilityIndex >= 0.35 ? '✅' : '⚠️'} |

### Formula Breakdown

**Harmony Index** = (layoutPHI × 0.618) + (avgContrast/maxContrast) - colorClashPenalty

- **Layout PHI**: Golden ratio adherence in typography scale
- **Contrast Ratio**: Average contrast / Maximum contrast
- **Color Clash Penalty**: LCH-based color harmony violations (hue separation 30-60°, chroma ±15-30)

---
`;

    // Praise Mode Section
    if (critique.praise.length > 0) {
      report += `## 🎉 Praise Mode - What's Working Well!\n\n`;
      critique.praise.forEach((praise: string) => {
        report += `${praise}\n\n`;
      });
      report += `---\n\n`;
    }

    // Issues Section
    report += `## Issues Found\n\n`;

    if (critique.issues.length === 0) {
      report += `*No design issues detected! Excellent work! 🎨*\n\n`;
    } else {
      // Group by severity
      const critical = critique.issues.filter((i: any) => i.severity === 'critical');
      const warnings = critique.issues.filter((i: any) => i.severity === 'warning');

      if (critical.length > 0) {
        report += `### 🔴 Critical Issues (${critical.length})\n\n`;
        critical.forEach((issue: any, i: number) => {
          report += this.formatIssue(issue, i + 1);
        });
      }

      if (warnings.length > 0) {
        report += `### ⚠️ Warnings (${warnings.length})\n\n`;
        warnings.forEach((issue: any, i: number) => {
          report += this.formatIssue(issue, i + 1);
        });
      }
    }

    report += `---\n\n`;

    // Color Palette Section
    report += this.generateColorPaletteSection(telemetry.telemetry.colors);

    // Typography Analysis Section
    report += this.generateTypographySection(telemetry.telemetry.typography);

    // Spacing Analysis Section
    report += this.generateSpacingSection(telemetry.telemetry.spacing);

    // Recommendations Section
    report += `## Recommendations\n\n`;
    critique.recommendations.forEach((rec: string) => {
      report += `- ${rec}\n`;
    });
    report += `\n---\n\n`;

    // Layout Metrics Section
    report += `## Layout Metrics\n\n`;
    report += `- **Total Elements**: ${telemetry.telemetry.layoutMetrics.totalElements}\n`;
    report += `- **Sampled Elements**: ${telemetry.telemetry.layoutMetrics.sampledElements}\n`;
    report += `- **Complexity**: ${telemetry.asymmetrica.complexity}\n`;
    report += `- **Regime**: ${telemetry.asymmetrica.regime}\n`;

    report += `\n---\n\n`;
    report += `*Generated by Design Sonar - Visual Quality Guardian 🎨*\n`;

    return report;
  }

  /**
   * Format individual issue with code example
   */
  private formatIssue(issue: any, index: number): string {
    let formatted = `#### ${index}. ${issue.type}\n\n`;
    formatted += `**Description:** ${issue.description}\n\n`;
    formatted += `**Suggestion:** ${issue.suggestion}\n\n`;

    if (issue.affectedElements && issue.affectedElements.length > 0) {
      formatted += `**Affected Elements:**\n`;
      issue.affectedElements.slice(0, 5).forEach((el: string) => {
        formatted += `- ${el}\n`;
      });
      formatted += `\n`;
    }

    if (issue.codeExample) {
      formatted += `**Code Fix:**\n\n`;
      formatted += `\`\`\`css\n${issue.codeExample}\n\`\`\`\n\n`;
    }

    return formatted;
  }

  /**
   * Generate color palette section
   */
  private generateColorPaletteSection(colors: any[]): string {
    const uniqueColors = new Map<string, any>();

    colors.forEach(c => {
      const hex = c.hex;
      if (!uniqueColors.has(hex)) {
        uniqueColors.set(hex, { ...c, count: 1 });
      } else {
        const existing = uniqueColors.get(hex)!;
        existing.count++;
      }
    });

    const colorArray = Array.from(uniqueColors.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 15); // Top 15 colors

    let section = `## Color Palette Analysis\n\n`;
    section += `**Total Unique Colors:** ${uniqueColors.size}\n`;
    section += `**Recommended:** ≤10 semantic tokens\n\n`;

    section += `| Color | Usage | Occurrences |\n`;
    section += `|-------|-------|-------------|\n`;

    colorArray.forEach(c => {
      section += `| \`${c.hex}\` | ${c.usage} | ${c.count} |\n`;
    });

    section += `\n---\n\n`;

    return section;
  }

  /**
   * Generate typography section
   */
  private generateTypographySection(typography: any[]): string {
    const headings = typography.filter(t => /^h[1-6]$/.test(t.element));

    if (headings.length === 0) {
      return `## Typography Analysis\n\n*No heading elements found*\n\n---\n\n`;
    }

    // Group by element type and calculate average size
    const headingStats: { [key: string]: number[] } = {};
    headings.forEach(h => {
      if (!headingStats[h.element]) headingStats[h.element] = [];
      headingStats[h.element].push(h.fontSize);
    });

    const avgSizes: { level: string; size: number }[] = [];
    Object.keys(headingStats).forEach(level => {
      const sizes = headingStats[level];
      const avgSize = sizes.reduce((sum, s) => sum + s, 0) / sizes.length;
      avgSizes.push({ level, size: avgSize });
    });

    // Sort by heading level
    avgSizes.sort((a, b) => {
      const levelA = parseInt(a.level.replace('h', ''));
      const levelB = parseInt(b.level.replace('h', ''));
      return levelA - levelB;
    });

    let section = `## Typography Analysis\n\n`;
    section += `| Heading | Avg Size | Ratio to Next |\n`;
    section += `|---------|----------|---------------|\n`;

    avgSizes.forEach((h, i) => {
      let ratio = 'N/A';
      if (i < avgSizes.length - 1) {
        const nextSize = avgSizes[i + 1].size;
        const r = h.size / nextSize;
        ratio = `${r.toFixed(3)}×`;
      }
      section += `| ${h.level} | ${h.size.toFixed(1)}px | ${ratio} |\n`;
    });

    section += `\n**Recommended Ratios:** 1.2×, 1.25×, 1.333×, 1.414×, 1.5×, 1.618× (golden)\n\n`;
    section += `---\n\n`;

    return section;
  }

  /**
   * Generate spacing section
   */
  private generateSpacingSection(spacing: any[]): string {
    if (spacing.length === 0) {
      return `## Spacing Analysis\n\n*No spacing data collected*\n\n---\n\n`;
    }

    // Analyze spacing distribution
    const spacingValues = spacing.map(s => s.value);
    const uniqueValues = Array.from(new Set(spacingValues)).sort((a, b) => a - b);

    // Group into grid-compliant and off-grid
    const gridScale = [0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 56, 64, 80, 96, 128];
    const onGrid: number[] = [];
    const offGrid: number[] = [];

    uniqueValues.forEach(v => {
      const isOnGrid = gridScale.some(grid => Math.abs(v - grid) <= 2);
      if (isOnGrid) {
        onGrid.push(v);
      } else {
        offGrid.push(v);
      }
    });

    let section = `## Spacing Analysis\n\n`;
    section += `**Total Spacing Values:** ${spacing.length}\n`;
    section += `**Unique Values:** ${uniqueValues.length}\n`;
    section += `**Grid-Compliant:** ${onGrid.length} (${((onGrid.length / uniqueValues.length) * 100).toFixed(1)}%)\n`;
    section += `**Off-Grid:** ${offGrid.length}\n\n`;

    if (offGrid.length > 0) {
      section += `**Off-Grid Values (should migrate to grid):**\n`;
      offGrid.slice(0, 10).forEach(v => {
        // Find nearest grid value
        const nearest = gridScale.reduce((prev, curr) =>
          Math.abs(curr - v) < Math.abs(prev - v) ? curr : prev
        );
        section += `- ${v.toFixed(0)}px → ${nearest}px (nearest grid value)\n`;
      });
      section += `\n`;
    }

    section += `**Recommended Grid Scale:** 4px, 8px, 16px, 24px, 32px, 48px, 64px\n\n`;
    section += `---\n\n`;

    return section;
  }

  /**
   * Save report to file
   */
  saveReport(content: string, route: string): string {
    const reportDir = join(process.cwd(), 'tests/ux-sonar/reports');

    try {
      mkdirSync(reportDir, { recursive: true });
    } catch (e) {
      // Directory might already exist
    }

    const filename = route.replace(/\//g, '_') || 'root';
    const timestamp = Date.now();
    const filepath = join(reportDir, `design_${filename}_${timestamp}.md`);

    writeFileSync(filepath, content);
    console.log(`[Design Report] Saved to: ${filepath}`);

    return filepath;
  }

  /**
   * Generate JSON report for programmatic use
   */
  generateJSONReport(critique: any, telemetry: any, route: string) {
    return {
      route,
      timestamp: new Date().toISOString(),
      critique,
      telemetry,
      baseline: telemetry.baseline || null
    };
  }

  /**
   * Save JSON report
   */
  saveJSONReport(report: any, route: string): string {
    const reportDir = join(process.cwd(), 'tests/ux-sonar/reports');

    try {
      mkdirSync(reportDir, { recursive: true });
    } catch (e) {
      // Directory might already exist
    }

    const filename = route.replace(/\//g, '_') || 'root';
    const timestamp = Date.now();
    const filepath = join(reportDir, `design_${filename}_${timestamp}.json`);

    writeFileSync(filepath, JSON.stringify(report, null, 2));
    console.log(`[Design Report JSON] Saved to: ${filepath}`);

    return filepath;
  }
}
